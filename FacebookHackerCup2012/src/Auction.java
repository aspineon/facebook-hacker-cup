import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;


/**
 * @Pradeep my idea was something like this (the idea was quite "obvious" to me, but it was a challenge to implement it - my implementation could be significantly improved; check my code (#17)). First, generate the prices and weights getting possibly a "tail" (i.e. chain) of unique numbers and then (possibly) a cycle. The whole thing can't be larger than 10^7 numbers each (i.e. if N>10^7, you're bound to get cycles).

To find the bargains, start with P=0 up to P=M-1 tracking the minimum weight value found so far. For each price P that is actually part of the generated prices sequence, there are two cases: it is either part of the "tail" (precycle) or it is in the cycle. If it is in the "tail", there is only one item with that price so just find the corresponding weight and see if it is smaller than the current minimum (if it is, that item is a bargain) and update the minimum as appropriate. The other case is a bit harder... you need to find the minimal weight that any of the items with this price P have, and count how many of them there are. To do this, I used another cycle (which I called "megacycle" in my code) which is basically the cycle of weights generated by going through the weights sequence by price_cycle_size steps (these are the weights that will be associated with a specific price that is part of the price cycle). Even then, it's not trivial to implement this, or even be completely sure it's fast enough (the test case I got took like 40-50s on my machine). Anyway, having found the minimal weight and the count, you do the same thing as in the simpler case (compare the weight to the current minimum and update the number by the item count if the weight is lower than the current minimum).

The horrible deal part is symmetric, even though my code doesn't really reflect that (i.e. it's duplicated where it shouldn't be). I also used a lot of memory (300-400MB), but I think I could reduce it by about a third or so. Sorry about not being super clear, it's kind of hard to explain it in a comment with no pictures etc. HTH :)
 * @author ipince
 *
 */
public class Auction {
    
    public static void main(String[] args) {
//        Random rand = new Random();
//        for (int mod = 2; mod < 1000; mod++) {
//        int mod = 100;
//            for (int i = 0; i < 1; i++) {
//                Sequence seq = new Sequence(rand.nextInt(mod), rand.nextInt(mod), rand.nextInt(mod), mod, 200);
//                for (int j = 0; j < 200; j++) {
//                    System.out.println(seq.next());
//                }
//            }
//        }
//        if (true)
//            System.exit(1);
        Scanner scanner = new Scanner(System.in);
        int cases = scanner.nextInt(); scanner.nextLine(); // skip to the end
        StringBuilder out = new StringBuilder();
        long start = System.currentTimeMillis();
        for (int i = 0; i < cases; i++) {
            long n = scanner.nextLong();
            int p1 = scanner.nextInt();
            int w1 = scanner.nextInt();
            int priceMod = scanner.nextInt();
            int weightMod = scanner.nextInt();
            int priceFactor = scanner.nextInt();
            int priceSummand = scanner.nextInt();
            int weightFactor = scanner.nextInt();
            int weightSummand = scanner.nextInt();
            Result result = fillBargainsAndTerribles(n, p1, priceMod, priceFactor % priceMod, priceSummand % priceMod,
                    w1, weightMod, weightFactor % weightMod, weightSummand % weightMod);
            out.append("Case #" + (i+1) + ": " + result.numTerribles + " " + result.numBargains + "\n");
        }
        System.out.println("Took " + (System.currentTimeMillis() - start) + "ms");
        System.out.println(out.toString());
    }
    
    private static Result fillBargainsAndTerribles(long n, int p1,
            int priceMod, int priceFactor, int priceSummand, int w1,
            int weightMod, int weightFactor, int weightSummand) {
        
        Sequence prices = new Sequence(p1, priceFactor, priceSummand, priceMod, n);
        Sequence weights = new Sequence(w1, weightFactor, weightSummand, weightMod, n);
        prices.next(); weights.next(); // For Product 1 is already done.
        
        // Setup
        Thresholds thresholds = new Thresholds();
        thresholds.pMax = p1;
        thresholds.pMin = p1;
        thresholds.wMax = w1;
        thresholds.wMin = w1;
        List<Product> bargains = new ArrayList<Product>();
        List<Product> terribles = new ArrayList<Product>();
        bargains.add(new Product(w1, p1));
        terribles.add(new Product(w1, p1));
        
        List<Product> newBargains = new ArrayList<Product>();
        List<Product> newTerribles = new ArrayList<Product>();
        
        if (prices.hasCycle() && weights.hasCycle()) {
            System.err.println("Both sequences have cycles");
            // Go through as many iterations as it takes to get both sequences "inside" a cycle.
            int minIterations = Math.max(prices.getPreCycleLength(), weights.getPreCycleLength()); // Must be > -1; could be 0
            
            // Also, check if we'll be done after doing this.
            if (minIterations >= n) {
                updateProducts(prices, weights, thresholds, bargains, terribles, newBargains, newTerribles, n);
                // we're done
                return new Result(bargains.size(), terribles.size());
            } else {
                updateProducts(prices, weights, thresholds, bargains, terribles, newBargains, newTerribles, minIterations);
                // update n
                n -= minIterations;
            }
            
            // OK. Both sequences are now inside a cycle. How long will it take for two products to repeat?
            // This is the product cycle length.
            long productCycleLength = lcm(prices.getCycleLength(), weights.getCycleLength());
            
            // Calculate and perform the remainder, if any.
            long remainder = n % productCycleLength;
            updateProducts(prices, weights, thresholds, bargains, terribles, newBargains, newTerribles, remainder);
            
            // Calculate and perform 1 cycle and calculate how many cycles we have left to go.
            long numCycles = n / productCycleLength;
            if (numCycles > 0) {
                System.err.println("Not done yet! Num cycles remaining: " + numCycles);
                // Calculate how many NEW bargains/terribles we add in a single cycle
                updateProducts(prices, weights, thresholds, bargains, terribles, newBargains, newTerribles, productCycleLength);
                return new Result(bargains.size() + (numCycles - 1) * newBargains.size(),
                        terribles.size() + (numCycles - 1) * newTerribles.size());
            }
            
        } else { // no cycles at all.
            System.err.println("No cycles!");
            updateProducts(prices, weights, thresholds, bargains, terribles, newBargains, newTerribles, n);
        }
        
        return new Result(bargains.size(), terribles.size());
    }

    private static void updateProducts(Sequence prices, Sequence weights,
            Thresholds thresholds, List<Product> allBargains, List<Product> allTerribles,
            List<Product> newBargains, List<Product> newTerribles, long n) {
        newBargains.clear(); newTerribles.clear();
        List<Product> remove = new ArrayList<Product>();
        for (long i = 2; i <= n; i++) {
            // TODO: will this compute?
            long pi = prices.next();
            long wi = weights.next();
            //System.out.println("P" + i + ": w:" + wi + " p:" + pi);
            
            if ((pi < thresholds.pMin && wi <= thresholds.wMin) ||
                    (pi <= thresholds.pMin && wi < thresholds.wMin)) { // 1
                // This product beats everything
                Product current = new Product(wi, pi);
                allBargains.clear();
                allBargains.add(current);
                newBargains.clear();
                newBargains.add(current);
                thresholds.pMin = pi;
                thresholds.wMin = wi;
            } else if ((wi < thresholds.wMin && pi > thresholds.pMin && pi <= thresholds.pMax) ||
                    (pi < thresholds.pMin && wi > thresholds.wMin && wi <= thresholds.wMax)) { // 3
                // Product is bargain and NOT terrible.
                // Remove current bargains that are beaten by this.
                remove.clear();
                Product current = new Product(wi, pi);
                for (Product b : allBargains) {
                    if (current.beats(b)) {
                        remove.add(b);
                    }
                }
                for (Product r : remove) {
                    allBargains.remove(r);
                    newBargains.remove(r);
                }
                allBargains.add(current);
                newBargains.add(current);
                thresholds.wMin = Math.min(thresholds.wMin, wi);
                thresholds.pMin = Math.min(thresholds.pMin, pi);
            } else if ((wi < thresholds.wMin && pi > thresholds.pMax) ||
                    (pi < thresholds.pMin && wi > thresholds.wMax)) {
                // Region 4.
                // Without loss of generality, consider the (wi < wMin && pi > pMax) part of Region 4.
                //
                // Product I (Pi) is a bargain: if it weren't there there must be a product A that beats it.
                // Suppose there is. We know A beats I iff wa <= wi AND pa < pi
                //                                      OR wa < wi AND pa <= pi.
                // But wi < wMin <= wa, so such product A cannot exist.
                //
                // In addition, Pi does not affect other current bargains.
                // That is, Pi does not beat any current bargain A. Suppose it did.
                // Then, since we know wi < wMin <= wa, we must also have pi <= pa.
                // But pi > pMax >= pa, so such product A cannot exist.
                //
                // Note the same arguments apply for terribles.
                //
                // => Product I is both a bargain and terrible. Nothing else is affected.
                Product current = new Product(wi, pi);
                allBargains.add(current);
                allTerribles.add(current);
                newBargains.add(current);
                newTerribles.add(current);
                thresholds.wMin = Math.min(thresholds.wMin, wi);
                thresholds.pMin = Math.min(thresholds.pMin, pi);
                thresholds.wMax = Math.max(thresholds.wMax, wi);
                thresholds.pMax = Math.max(thresholds.pMax, pi);
            } else if ((wi >= thresholds.wMin && wi < thresholds.wMax && pi > thresholds.pMax) ||
                    (pi >= thresholds.wMin && pi < thresholds.pMax && wi > thresholds.wMax)) { // 6
                // Region 6.
                // Product CANNOT be bargain, because pi > pMax >= pa for any Product A.
                // Product MUST be terrible, because if it weren't, it would beat some other Product A.
                // But pi > pMax >= pa, so such Product A does not exist.
                // 
                // However, some other terribles may be terribles no more, since they may beat Product I.
                //
                // Product is terrible and NOT bargain
                // Remove current terribles that are no more
                Product current = new Product(wi, pi);
                remove.clear();
                for (Product t : allTerribles) {
                    if (t.beats(current)) {
                        remove.add(t);
                    }
                }
                for (Product r : remove) {
                    allTerribles.remove(r);
                    newTerribles.remove(r);
                }
                allTerribles.add(current);
                newTerribles.add(current);
                
                thresholds.wMax = Math.max(thresholds.wMax, wi);
                thresholds.pMax = Math.max(thresholds.pMax, pi);
            } else if ((wi > thresholds.wMax && pi >= thresholds.pMax) ||
                    (wi >= thresholds.wMax && pi > thresholds.pMax)) { // 2
                // This product is the very worst
                Product current = new Product(wi, pi);
                allTerribles.clear();
                allTerribles.add(current);
                newTerribles.clear();
                newTerribles.add(current);
                thresholds.pMax = pi;
                thresholds.wMax = wi;
            } else { // 5
                // Product may or may not be a bargain/terrible.
                // Check against current bargains/terribles to find out.
                Product current = new Product(wi, pi);
                remove.clear();
                boolean bargain = true;
                for (Product b : allBargains) {
                    if (b.beats(current)) {
                        // Current cannot be bargain
                        bargain = false;
                    }
                    if (current.beats(b)) {
                        remove.add(b);
                    }
                }
                for (Product r : remove) {
                    allBargains.remove(r);
                    newBargains.remove(r);
                }
                if (bargain) {
                    allBargains.add(current);
                    newBargains.add(current);
                }
                
                remove.clear();
                boolean terrible = true;
                for (Product t : allTerribles) {
                    if (t.beats(current)) {
                        remove.add(t);
                    }
                    if (current.beats(t)) {
                        terrible = false;
                    }
                }
                for (Product r : remove) {
                    allTerribles.remove(r);
                    newTerribles.remove(r);
                }
                if (terrible) {
                    allTerribles.add(current);
                    newTerribles.add(current);
                }
                
                // No changes to max/mins
            }
        }
    }
    
    private static long gcd(long a, long b) {
        while (b > 0) {
            long temp = b;
            b = a % b; // % is remainder
            a = temp;
        }
        return a;
    }
    
    private static long lcm(long a, long b) {
        return a * (b / gcd(a, b));
    }
    
    private static class Sequence {
        
        private List<Long> elements = new ArrayList<Long>();
        private int cycleStartIndex = 0;
        private boolean hasCycle = false;
        private int currentIndex = 0;
        
        public Sequence(int initial, int factor, int summand, int mod, long n) {
            precalculateElements(initial, factor, summand, mod, n);
        }
        
        public long next() {
            if (currentIndex == elements.size()) {
                currentIndex = cycleStartIndex;
            }
            return elements.get(currentIndex++);
        }
        
        public int getPreCycleLength() {
            return cycleStartIndex;
        }
        
        public int getCycleLength() {
            if (hasCycle) {
                return elements.size() - cycleStartIndex;
            } else {
                return -1;
            }
        }
        
        public boolean hasCycle() {
            return hasCycle;
        }

        /**
         * Calculates the series of integers based on the formula:
         * p_next = ( factor * p_previous + summand ) mod mod + 1
         * 
         * Calculates ONLY the elements in the series until there is a repetition or until
         * n elements have been calculated.
         * 
         * Populates a list with the non-repeated elements, starting with initial. If there
         * is a cycle, sets cycleStartIndex to the cycle's starting position.
         * 
         * Note that at worst, the elements will repeat after mod iterations. Thus,
         * running time is O(min(mod, n)).
         */
        private void precalculateElements(long initial, long factor, long summand, int mod, long n) {
            long prev = initial;
            long current;
            Set<Long> seen = new HashSet<Long>();
            seen.add(initial);
            elements.clear();
            elements.add(initial);
            for (int i = 0; i < n; i++) {
                // Safe to use int iterating over long because iters <= min(mod, n)
                current = ((factor * prev + summand) % mod) + 1;
                if (seen.contains(current)) {
//                    if (current != initial) {
//                        System.err.println("Initial: " + initial);
//                        System.err.println("Factor: " + factor);
//                        System.err.println("Summand: " + summand);
//                        System.err.println("Mod: " + mod);
//                    }
                    // Repeat! Current list is done. Set cycleIndex
                    cycleStartIndex = elements.indexOf(current);
                    hasCycle = true;
                    return;
                } else {
                    elements.add(current);
                    seen.add(current);
                }
                prev = current;
            }
        }
    }

    /**
     * Represents a product. Immutable.
     * 
     * Careful: use referential equality for performance when checking containment.
     *   new Product(1, 2).equals(new Product(1, 2)) is FALSE
     */
    private static class Product {
        private final long weight;
        private final long price;
        
        public Product(long weight, long price) {
            this.weight = weight;
            this.price = price;
        }

        public boolean beats(Product b) {
            return (weight < b.weight && price <= b.price) ||
                    (price < b.price && weight <= b.weight);
        }
    }
    
    /**
     * Mutable container for price and weight thresholds. 
     */
    private static class Thresholds {
        public long pMin;
        public long pMax;
        public long wMin;
        public long wMax;
    }
    
    private static class Result {
        public long numBargains = 0;
        public long numTerribles = 0;
        public Result(long numBargains, long numTerribles) {
            this.numBargains = numBargains;
            this.numTerribles = numTerribles;
        }
    }

}
